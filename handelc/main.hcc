#include "vlab.hch"
#include "fsl.hch"
#include "dac.hch"
#include "buffer.hch"
#include "mixer.hch"
#include "main.hch"

// When this signal is high, output_driver will not read from the buffer.
// This is used whilst waiting for the buffer to reach a certain fullness and
// to prevent RAM conflicts whilst clearing the buffer.
unsigned 1 pause_playback = 1;

void main(void) {
	initialise();
    
	par {
		fsl_driver();
		dac_driver();
		in_driver();
		out_driver();
	}
}

// Reads commands/samples from FSL and inserts them into the appropriate part of the buffer, mixing
// with existing buffer contents.
void in_driver() {
	// The data word from the FSL bus.
	unsigned 32 fsl_data;
	// RAM cursor for erasing the buffer.
	unsigned 14 erase_cursor;
	// The width of all samples in the current packet.
	unsigned 1  packet_width;
	// The length of the current packet.
	unsigned 13 length;
	
	// Process data from FSL into buffer
	while (1) {
		// The protocol is one-way, so to ensure that the handel-c component is in sync with
		// the microblaze component, wait for a synchronisation sequence before processing an instruction.
		fsl_read ? fsl_data;
		if (fsl_data != 0xFFFFFFFF) continue;
		fsl_read ? fsl_data;
		if (fsl_data != 0x00000000) continue;
		fsl_read ? fsl_data;
		if (fsl_data != 0xFFFFFFFF) continue;
		
		// If execution reaches here, both components are in sync.
		// Receive a new packet. The first FSL word will be the preamble/reset instruction.
		fsl_read ? fsl_data;
        
		if (fsl_data[IDX_TYPE] == TYPE_RESET) { // Reset bit.
			// Pause playback to prevent RAM conflicts whilst erasing.
			pause_playback = 1;
            
			// Set the mode of the DAC drivers as specified by the packet.
			stream_8k.mode  = 0 @ fsl_data[IDX_MODE_8K];
			stream_44k.mode = fsl_data[IDX_MODE_44K];
            
			// Reset all buffer information.
			buffer_8k.write_addr  = 0;
			buffer_8k.used        = 0;
			buffer_8k.read_addr   = 0;
			buffer_44k.write_addr = 0;
			buffer_44k.used       = 0;
			buffer_44k.read_addr  = 0;

			// Clear the buffer.
			do {
				par {
					// Use both ports to halve the time needed.
					buffer.out[erase_cursor]  = 0x000;
					buffer.in[erase_cursor+1] = 0x000;
					erase_cursor += 2;
				}
			} while (erase_cursor[13:1] != 0); // Least significant bit ignored as cursor increments by two
			
			// Skip the rest
			continue;
		}

		// Extract the packet information from the packet.
		packet_width = fsl_data[IDX_WIDTH];
		interval     = fsl_data[IDX_INTERVAL];
		length       = fsl_data[IDX_LENGTH];
		
		// Select which page of the buffer to write to.
		if (fsl_data[IDX_BUFFER] == BUFFER_8K) {
			mixer_buffer = &buffer_8k;
		}
		else {
			mixer_buffer = &buffer_44k;
		}

		// Determine where in the buffer this packet is situated.
		mixer_buffer->write_addr = fsl_data[IDX_POSITION];
		
		// Write all samples in packet into the buffer.
		while (length != 0) {
			// Get next sample from FSL.
			par {
				fsl_read ? fsl_data;
				
				// Decrease the length counter by the number of bytes to write into the buffer, but make sure
				// length does not underflow, or the loop will not terminate.
				// Whilst the length is normally a multiple of four, this step is still necessary to prevent
				// a corrupt packet from causing an infinite loop.
				
				// If the 11 most-significant bits are zero, then subtracting four will always underflow.
				if (length[12:2] == 0) { 
					length = 0;
				}
				// Otherwise it is safe to subtract.
				else {
					length -= 4;
				}
			}
			
			// Depending on the packet width, a different number of samples can be read from a single FSL word.
			if (packet_width == WIDTH_8BIT) {
				mixer_next(0 @ (unsigned 11)(fsl_data[31:24] @ 0));
				mixer_next(0 @ (unsigned 11)(fsl_data[23:16] @ 0));
				mixer_next(0 @ (unsigned 11)(fsl_data[15:8]  @ 0));
				mixer_next(0 @ (unsigned 11)(fsl_data[7:0]   @ 0));
			}
			else {
				// 16-bit samples...
				mixer_next(fsl_data[31:21] @ ~fsl_data[20]);
				mixer_next(fsl_data[15:5]  @ ~fsl_data[4]);
			}
		}
        
		// Make sure playback isn't paused if the buffer is above a certain size.
		// Only check the 4 most-signifiant bits to give the buffer some head-room to expand before the samples
		// are read. Otherwise the buffer may overflow.
		if (mixer_buffer->used[12:9] == 0xF) {
			pause_playback = 0;
		}
		else {
			delay;
		}
	}
}

// Reads the contents of the buffer and outputs them to DAC module.
void out_driver() {
	while (1) {
		// Only output to DAC if playback is not paused and the DAC module is ready to receive.
		if (~pause_playback && ~stream_8k.ready) {
			par {
				// Send next sample to DAC module.
				stream_8k.buffer = BufferIn_Get(buffer_8k);
				stream_8k.ready = 1;
			}
			// After reading, clear that location in the buffer to prevent it from being mixed back in by the mixer.
			BufferIn_Get(buffer_8k) = 0x000;
			// Incremen the read location cursor for the next read.
			buffer_8k.read_addr++;
		}
		else {
			delay;
		}

		// Do the same again, but for the 44K buffer.
		if (~pause_playback && ~stream_44k.ready) {
			par {
				stream_44k.buffer = BufferIn_Get(buffer_44k);
				stream_44k.ready = 1;
			}
			BufferIn_Get(buffer_44k) = 0x000;
			buffer_44k.read_addr++;
		}
	}
}