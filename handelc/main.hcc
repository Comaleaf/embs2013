#include "vlab.hch"
#include "fsl.hch"
#include "dac.hch"
#include "buffer.hch"
#include "mixer.hch"
#include "main.hch"

unsigned 14 read_cursor;

void main(void) {
	initialise();
	
	par {
		uart_driver();
		fsl_driver();
		dac_driver();
		mixer_driver();
		fsl_to_buffer_driver();
		buffer_to_dac_driver();
	}
}

void fsl_to_buffer_driver() {
	unsigned 32 fsl_data;
	
	unsigned 1  sample_width;
	unsigned 10 length;
	
	// Process data from FSL into buffer
    while (1) {
		fsl_read ? fsl_data;
		
		// Receive a new packet
		
		if (fsl_data[IDX_TYPE] == TYPE_RESET) { // Reset bit
			// Start buffer again from beginning
			par {
				buffer_used     = 0;
				buffer_is_ready = 0;
				read_cursor     = 0;
			}
			
			par {
				mixer_cursor = 0;
				dac_mode_8k  = fsl_data[IDX_MODE_8K];
				dac_mode_44k = fsl_data[IDX_MODE_44K];
			}
			
			// Clear buffer
			do {
				par {
					// Can use both RAM ports because the buffer consumer won't read RAM whilst buffer_used = 0
					buffer.consumer[read_cursor] = 0x0;
					buffer.mixer[read_cursor+1] = 0x0;
					read_cursor += 2;
				}
			} while (read_cursor != 0 && read_cursor != 1);
			
			// Skip the rest
			continue;
		}
		
		par {
			sample_width = fsl_data[IDX_WIDTH];
			interval = fsl_data[IDX_INTERVAL];
			length = fsl_data[IDX_LENGTH];
			
			// Determine position in the buffer to write values into
			if (fsl_data[IDX_OFFSET][13] == 1) {
				// Go backwards
				mixer_cursor -= ~fsl_data[IDX_OFFSET] + 1;
			}
			else {
				// Go forwards
				mixer_cursor += fsl_data[IDX_OFFSET];
			}
		}
		
		while (length != 0) {
			while (buffer_used > 4090) buffer_is_ready = 1;
			
			// Get next samples from FSL
			par {
				fsl_read ? fsl_data;
				length -= 4;
			}
			
			if (sample_width == WIDTH_8BIT) {
				// Can read 4 samples at a time from FSL bus with 8-bit samples
				mixer_next ! (fsl_data[31:24] @ 0);
				mixer_next ! (fsl_data[23:16] @ 0);
				mixer_next ! (fsl_data[15:8] @ 0);
				mixer_next ! (fsl_data[7:0] @ 0);
			}
			else {
				// Can read 2 samples at a time from FSL bus with 16-bit samples
				mixer_next ! (fsl_data[31:21] @ ~fsl_data[20]);
				mixer_next ! (fsl_data[15:5] @ ~fsl_data[4]);
			}
		}
	}
}

void buffer_to_dac_driver() {
	// Consume buffer data and output on DAC
	while (1) {
		if (buffer_used > 0 && buffer_is_ready) {
			par {
				dac_write_44k ! buffer.consumer[read_cursor];
				buffer_used--;
			}
			par {
				buffer.consumer[read_cursor] = 0x0; // Clear part of buffer after read (so that it won't be mixed next time round)
				read_cursor++;
			}
		}
		else {
			delay;
		}
	}
}