#include "vlab.hch"
#include "fsl.hch"
#include "dac.hch"
#include "buffer.hch"
#include "mixer.hch"
#include "main.hch"

unsigned 1 pause_playback = 1;

void main(void) {
	initialise();
		
	par {
		fsl_driver();
		dac_driver();
		mixer_driver();
		fsl_to_buffer_driver();
		buffer_to_dac_driver();
		buffer_used_driver();
	}
}

void fsl_to_buffer_driver() {
	unsigned 32 fsl_data;
	unsigned 14 erase_cursor;
	unsigned 1  sample_width;
	unsigned 10 length;
	
	// Process data from FSL into buffer
    while (1) {
		fsl_read ? fsl_data;
		
		// Receive a new packet
		
		if (fsl_data[IDX_TYPE] == TYPE_RESET) { // Reset bit
			// Start buffer again from beginning
			pause_playback = 1;
			dac_8k.mode    = fsl_data[IDX_MODE_8K];
			dac_44k.mode   = fsl_data[IDX_MODE_44K];
			mixer_cursor   = 0;
			buffer_used    = 0; // These two are zeroed last to give the buffer consumer enough cycles to avoid conflicts
			read_cursor    = 0;

			// Clear buffer
			do {
				par {
					// Can use both RAM ports because the buffer consumer won't read RAM whilst buffer_used = 0
					buffer.consumer[erase_cursor] = 0x800;
					buffer.mixer[erase_cursor+1]  = 0x800;
					erase_cursor += 2;
				}
			} while (erase_cursor[13:1] != 0); // Least significant bit should be ignored because cursor increments by two
			
			// Skip the rest
			continue;
		}

		sample_width = fsl_data[IDX_WIDTH];
		interval     = fsl_data[IDX_INTERVAL];
		length       = fsl_data[IDX_LENGTH];
		
		if (fsl_data[IDX_BUFFER]) {
			mixer_buffer = &buffer_8k;
		}
		else {
			mixer_buffer = &buffer_44k;
		}

		// Determine position in the buffer to write values into
		if (fsl_data[IDX_OFFSET][13] == 1) {
			// Go backwards
			mixer_buffer->write_addr -= ~fsl_data[IDX_OFFSET] + 1;
			USED_DEC(mixer_buffer, length); // if we have to go back, remove this from the used count
		}
		else {
			// Go forwards
			mixer_buffer->write_addr += fsl_data[IDX_OFFSET];
		}
		
		while (length != 0) {
			while (mixer_buffer->used[12:2] == 0x7FF) pause_playback = 0; // buffer_used > BUFFER_WIDTH-4 (ignore 2 least significant bits)
			
			// Get next samples from FSL
			par {
				fsl_read ? fsl_data;
				length -= 4;
			}
			
			if (sample_width == WIDTH_8BIT) {
				// Can read 4 samples at a time from FSL bus with 8-bit samples
				mixer_next ! (fsl_data[31:24] @ 0);
				mixer_next ! (fsl_data[23:16] @ 0);
				mixer_next ! (fsl_data[15:8]  @ 0);
				mixer_next ! (fsl_data[7:0]   @ 0);
			}
			else {
				// Can read 2 samples at a time from FSL bus with 16-bit samples
				mixer_next ! (fsl_data[31:21] @ ~fsl_data[20]);
				mixer_next ! (fsl_data[15:5]  @ ~fsl_data[4]);
			}
		}
	}
}

void buffer_to_dac_driver() {
	// Consume buffer data and output on DAC
	while (1) {
		try {
			try {
				if (~dac_8k.write) {
					par {
						dac_8k.buffer = buffer.consumer[CONSUMER_ADDR(buffer_8k)];
						dac_8k.write = 1;
					}
					buffer.consumer[0 @ buffer_8k.read] = 0x800; // Clear part of buffer after read (so that it won't be mixed next time round)
					buffer_used_dec ! &buffer_8k.used;
					buffer_8k.read++;
				}

				if (~dac_44k.write) {
					par {
						dac_44k.buffer = buffer.consumer[CONSUMER_ADDR(buffer_44k)];
						dac_44k.write = 1;
					}
					buffer.consumer[1 @ buffer_44k.read] = 0x800;
					USED_DEC(buffer_44k, 1);
					buffer_44k.read++;
				}
			}
			reset (buffer_8k.used == 0 || buffer_44.used == 0) {
				pause_playback = 1;
			}
		}
		reset (pause_playback) {
			delay;
		}
	}
}