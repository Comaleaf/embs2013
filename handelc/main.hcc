#include "vlab.hch"
#include "fsl.hch"
#include "dac.hch"
#include "main.hch"

#define RAM 4096

mpram {
	wom unsigned 12 write[RAM];
	rom unsigned 12 read[RAM];
} buffer with {block=1};

struct {
	unsigned 12 write;
	unsigned 12 read;
} cursor;

unsigned 1 buffer_is_ready;
unsigned 12 buffer_size;

void buffer_append(unsigned 12 in) {
	while (buffer_size == RAM-1) delay; // don't overwrite buffer
	par {
		buffer.write[cursor.write] = in;
		cursor.write++;
		buffer_size++;
	}
}

void main(void) {
	unsigned 32 fsl_data;
	unsigned 12 buffer_in;
	
    sample_rate = CYCLES_8K;
	cursor.write = 0;
	cursor.read = 0;
	buffer_size = 0;
    
	initialise();
	
	par {
		uart_driver();
		fsl_driver();
		dac_driver();
		while (1) {
			fsl_read ? fsl_data;
			
			if (fsl_data \\ 30 == OP_8BIT) {
				buffer_append(fsl_data <- 12); // get least significant 12 bits
			}
			else if (fsl_data \\ 30 == OP_16BIT) {
				// use parity bit as a 'pivot' to turn an unsigned integer around. positive side becomes upper half of unsigned integer.
				buffer_append(~fsl_data[15] @ fsl_data[14:4]); // use the negative part
			}
			else {
				par {
					switch (fsl_data <- 3) {
						case 1: sample_rate = CYCLES_8K;  break;
						case 2: sample_rate = CYCLES_11K; break;
						case 3: sample_rate = CYCLES_22K; break;
						case 4: sample_rate = CYCLES_44K; break;
					}
					cursor.write = 0;
					cursor.read = 0;
					buffer_size = 0;
				}
			}
		}
		while (1) {
			// When buffer is empty, refill buffer before playing again (to prevent stuttering)
			if (buffer_size >= RAM-1) {
				buffer_is_ready = 1;
			}
			else if (buffer_size == 0) {
				buffer_is_ready = 0;
			}
		}
		while (1) {
			while (!buffer_is_ready) delay;
			par {
				dac_write ! buffer.read[cursor.read];
				cursor.read++;
				buffer_size--;
			}
		}
	}
}