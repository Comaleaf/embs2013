#include "mixer.hch"
#include "vlab.hch"
#include "dac.hch"

DacInfo dac_8k;
DacInfo dac_44k;

// This macro counts down a counter once per cycle. Each time the counter is zero, it
// is effectively one tick in the simulated clock domain for each DAC.
macro proc Clock_Divider(dac_info, number_of_cycles) {
	while (1) {
		if (dac_info.counter == 0) {
			// Counter has reached zero. Reset to the number of cycles needed before the next tick.
			dac_info.counter = number_of_cycles;
		}
		else {
			dac_info.counter--;
		}
	}
}

// 
macro proc Output_Channel(dac_info) {
	while (1) {
		if (dac_info.mode != 0) {
			if (dac_info.write && dac_info.counter == 0) {
				par {
					buffer = mix(dac_8k.buffer, dac_44k.buffer);
					output = 1;
					dac_info.write = 0;
				}
			}
			else {
				delay;
			}
		}
		else {
			dac_info.buffer = 0;
		}
	}
}

void dac_driver() {
	unsigned 12 buffer;
	unsigned 1  output;
	
	par {
		Clock_Divider(dac_8k.counter,  DIVIDE_8K);
		Clock_Divider(dac_44k.counter, DIVIDE_44K << (0 @ (3 - dac_44k.mode)));
		Output_Channel(dac_8k);
		Output_Channel(dac_44k);
		while (1) {
			if (output == 1) {
				dac_write_to_output(0xF, buffer);
				output = 0;
			}
			else {
				delay;
			}
		}
	}
}