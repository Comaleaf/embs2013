#include "mixer.hch"
#include "vlab.hch"
#include "dac.hch"

StreamInfo stream_8k;
StreamInfo stream_44k;

unsigned 12 output_buffer;
unsigned 1  output_ready;

// This macro counts down a counter once per cycle. Each time the counter is zero, it
// is effectively one tick in the simulated clock domain for each DAC.
macro proc Clock_Divider(dac_info, number_of_cycles) {
	while (1) {
		if (dac_info.counter == 0) {
			// Counter has reached zero. Reset to the number of cycles needed before the next tick.
			dac_info.counter = number_of_cycles;
		}
		else {
			dac_info.counter--;
		}
	}
}

// Mixes the given stream to the DAC output buffer.
macro proc Mix_Stream(stream) {
	while (1) {
		// Don't do anything unless the stream is enabled.
		if (stream.mode != 0) {
			// Only mix if there is a sample ready to mix on the stream, and if the clock tick is
			// an output tick (when counter reaches zero).
			if (stream.ready && stream.counter == 0) {
				par {
					output_buffer = mix(stream_8k.buffer, stream_44k.buffer);
					output_ready = 1;
					stream.ready = 0;
				}
			}
			else {
				delay;
			}
		}
		else {
			stream.buffer = 0;
		}
	}
}

void dac_driver() {	
	par {
		// Set-up clocks for both streams.
		Clock_Divider(stream_8k,  DIVIDE_8K);
		Clock_Divider(stream_44k, DIVIDE_44K << (0 @ (3 - stream_44k.mode)));
		// Mix both streams into the output.
		Mix_Stream(stream_8k);
		Mix_Stream(stream_44k);
		// Output mixed streams.
		while (1) {
			if (output_ready == 1) {
				dac_write_to_output(0xF, output_buffer); // All channels.
				output_ready = 0;
			}
			else {
				delay;
			}
		}
	}
}