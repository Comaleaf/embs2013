#include "minivlab.h"
#include "utilities.h"
#include "main.h"
#include "gui.h"

#define IS_PLUS_OR_MINUS(x) (x == '+' || x == '-')

char input[50];
short cursor;

// Display usage message.
void gui_usage() {
	uart_send_string(UART, "\r\nUsage: to enable channel n, type +n. To disable, type -n. Multiple commands\r\nmay be included on one line, separated by space. Starting the line\r\nwith ! will disable all other channels.\r\nExamples: \"+4 -5\" enables ch.4 and disables ch.5; \"!+2\" enables ch.2 and\r\ndisables all other channels."); 
}

// Display the initial prompt, and clear the input string.
void gui_prompt() {
	uart_send_string(UART, "\r\n> ");
	
	// Wipe input string. This ensures there is always a zero-character where the user input leaves off.
	while (cursor > 0) {
		input[cursor--] = 0;
	}
}

void gui_accept(char c) {
	// If enter is pressed, and there have been at least 2 characters...
	if (c == '\r' && cursor >= 2) {
		// Process the input
		gui_process();
	}
	// If a backslash (and there's something to delete), then delete the last character.
	else if (c == '\b' && cursor > 0) {
		uart_send_string(UART, "\b \b"); // Backspace, clear, backspace
		input[cursor--] = 0;
	}
	// Allow ! at the beginning of the string only.
	else if (c == '!' && cursor == 0) {
		input[cursor++] = c;
		uart_send_char(UART, c);
	}
	// Digits.
	else if (IS_DIGIT(c) && 
		// Only allow a digit after a digit or a plus or minus.
		(IS_DIGIT(input[cursor-1]) || IS_PLUS_OR_MINUS(input[cursor-1])) &&
		// But not after two digit.
		(!IS_DIGIT(input[cursor-2]) || cursor == 1)) {
		input[cursor++] = c;
		uart_send_char(UART, c);
	}
	// +/-
	else if (IS_PLUS_OR_MINUS(c) && (cursor == 0 || input[cursor-1] == ' ' || input[cursor-1] == '!')) {
		input[cursor++] = c;
		uart_send_char(UART, c);
	}
	// Space
	else if (c == ' ' && IS_DIGIT(input[cursor-1]) )  {
		input[cursor++] = c;
		uart_send_char(UART, c);
	}
}

// Processes the string generated by gui_accept().
void gui_process() {
	unsigned char chan_id;
	char enable;
	int channels;
	
	// If the first character is a !, treat the input as if no channels were enabled.
	if (input[0] == '!') {
		channels = 0;
		cursor = 1;
	}
	// Otherwise, use the currently enabled channels as the base configuration.
	else {
		channels = get_channels();
		cursor = 0;
	}
	
	// Keep iterating whilst there are still commands.
	while (input[cursor] != 0) {
		// Is the next command an enable or a disable.
		enable = (input[cursor++] == '+');
		// The first numeral in the channel ID given.
		chan_id = (input[cursor++] - '0');
			
		// Is there a second digit?
		if (IS_DIGIT(input[cursor])) {
			// Shift the first numeral along and insert the second digit.
			chan_id = (chan_id*10) + (input[cursor++] - '0');
		}
		
		// Only do this if it's a valid channel (between 1 and 20 inclusive).
		if (chan_id != 0 && chan_id <= 20) {
			// Enable/disable the channel's bit.
			if (enable) {
				channels |= (1<<chan_id);
			}
			else {
				channels &= ~(1<<chan_id);
			}
		}
		
		// Consume the space character before the next command.
		cursor++;
	}
	
	// Set the channel configuration to the newly set channels.
	set_channels(channels);
	// Redisplay the prompt.
	gui_prompt();
}
